# 数据类型

## 标量类型

| 分类    |  类型  |
| ------- | ------|
| 整数类型 | i8, i16, i32, i64, i128, isize, u8, 816, u32, u64, u128, usize|
| 浮点类型 | f32, f64 |
| 布尔类型 | bool (true, false)|
| 字符类型 | char |

### 整数类型
| Length   | Signed | Unsigned |
| -------- | ------ | -------- |
| 8-bit    |  i8    | u8       |
| 16-bit   |  i16   | u16      |
|  32-bit  |  i32   |  u32     |
|  64-bit  |  i64   |  u64     |
|  128-bit |  i128  |  u128    |
|  arch    |  isize |  usize   |

#### 整数字面值

| Number literals| Example      |
|----------------|--------------|
| Decimal        |  98_200      |
| Hex            |  0xff        |
| Octal          |  0o75        |
| Binary         |  0b1111_0011 |
| Byte(u8 only)  |  b'A'        |

除了 byte 类型外，所有整数字面值都可以使用类型后缀：
```rust
let x = 9122i16
let y = 0xffi64
let b = 0b1100_1011u8
```

!!! Tip
    Rust 默认整数类型为 i32

#### 整数溢出

整数溢出指：值超过了类型的最大范围。

例如：u8的范围是 0～255，如果你把一个 u8 类型变量设为 256，那么：

- 调试模式下：Rust 会检查整数溢出，在发生溢出时 panic
- 发布模式下：Rust 不会检查整数溢出，在发生溢出时进行「环绕」操作：
    - 256 变成 0, 257 变成 1...
    - 不过程序不会 panic

### 浮点类型

Rust 浮点类型使用 IEEE-754 标准。

Rust 支持对浮点类型取余，但要求两边都是同类型浮点数才行，例如：
```rust
let x: f32 = 1.0
let y: f32 = 0.3
let z = x % y   // z 的值为 0.1
```

!!! Tip
    Rust 默认整数类型为 f64

## 复合类型

### 元组 Tuple

元组是一组 {++有序的、不可变的++} 元素的集合。

元组可以将多个类型的多个值放在一个类型里。

元组的长度是固定的，一旦声明就无法改变。

- 元组的声明形式： `(类型1, 类型2, ...)`;
- 元组的赋值形式： `(值1, 值2, ...)`;
- 元组的访问形式： `元组名称.下标`，使用 `.` 运算符。

!!! example

    ```rust 
    fn main() {
        let tup: (i32, f64, u8) = (100, 3.14, 5);
        println!("{}, {}, {}", tup.0, tup.1, tup.2);
    }
    ```

元组可以被解构，例如:

```rust
let tup: (i32, f64, u8) = (100, 3.14, 5);
let (x, y, z) = tup;
```


### 数组

数组是一组 {++有序的，可变的++} 元素的集合。

数组中的值类型必须相同。

数组的长度是固定的，一旦声明就无法改变。

- 数组的声明形式: `[类型; 长度]`;
- 数组的赋值形式: `[值1, 值2, ...]`;
- 数组的访问形式: `数组[下标]`，使用 `[]` 运算符。

!!! example

    ```rust
    let a:[i64; 5] = [1, 2, 3, 4, 5];
    ```

当数组下标越界时，Rust 编译器可以检查出简单情况，但是复杂情况就检查不了。

一旦数组下标越界，运行时会报错。（runtime 会 panic）

简单情况，编译器能检查出来：
```rust
fn main() {
    let arr: [i32; 5] = [10, 11, 12, 13, 14];

    let index = 10;
    let elem = arr[index];  // 这种情况编译器是能检查出来的
}
```

复杂情况，编译器也无能为力：
```rust
fn main() {
    let arr: [i32; 5] = [10, 11, 12, 13, 14];

    let index = [5, 7, 8];
    let elem = arr[index[1]];   // 这种情况编译器检查不出来的，运行时会 panic
}
```

