# 流程控制

## 判断

```rust
//
if cond {
    ...
}

//
if cond {
    ...
} else {
    ...
}

//
if cond {
    ...
} else if {
    ...
}

//
if cond {
    ...
} else if {
    ...
} else {
    ...
}
```

判断条件必须为 bool。 0, 空字符串， null 等不能作为判断条件。

`if + else` 是一个 ==表达式==，可以赋值给一个变量。也就是说，可以这么玩：
```rust
fn main() {
    let x = 10;
    let y = if x > 10 { "no" } else { "yes" };
}
```
但是要求 if 的块和 else 的块返回值类型相同。

反例：
```rust
fn main() {
    let y = if true { "no" } else { 6 };
    // `if` and `else` have incompatible types. expected `&str`, found integerrustc(E0308)
}
```

有了这个特性，就可以这样写 min() 函数：
```rust
fn min(num1: i32, num2: i32) -> i32 {
    if num1 < num2 { num1 } else { num2 }
}
```

## 循环

```rust
while cond {
}

loop {
}

for elem in iterater {
}
```

### while
while 循环需要带上条件，每次进行循环之前都需要判断一下条件是否为 true.

```rust
fn main() {
    let mut count = 0;
    while count < 10 {
        println!("{}", count);
        count = count + 1;
    }
}
```

### loop
loop 会一直循环，直到达到条件后显式的 break 出去。

```rust
fn main() {
    let mut count = 0;
    loop {
        println!("{}", count);
        count += 1;
        if count == 5 {
            break;
        }
    }
}

// 0 1 2 3 4
```

break 的时候可以带上值，这个值就作为 loop 块的返回值。那么可以像下面这么玩：

```rust
fn main() {
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };

    println!("{}", result); // 20
}
```

### for

for 循环最常用。

```rust
fn main() {
    let arr = [0, 1, 2, 3, 4];
    for elem in arr.iter() {
        println!("{}", elem);
    }
}
```
