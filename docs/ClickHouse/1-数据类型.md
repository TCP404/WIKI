# 数据类型

## 数值类型
ch 中数值类型只有固定长度，而且也非常好记。他们的长度分别为 8 位、16 位、32 位、64 位等。

### 整数
| Type   | Byte | Alias               | Ranges               |
|--------|------|---------------------|----------------------|
| Int8   | 1    | TinyInt, Bool, Int1 | [-2^8-1^ : 2^8-1^-1]     |
| Int16  | 2    | SmallInt, Int2      | [-2^16-1^ : 2^16-1^-1]   |
| Int32  | 4    | Int, Int4, Integer  | [-2^32-1^ : 2^32-1^-1]   |
| Int64  | 8    | BigInt              | [-2^63-1^ : 2^63-1^-1]   |
| Int128 | 16   |                     | [-2^127-1^ : 2^127-1^-1] |
| Int256 | 32   |                     | [-2^255-1^ : 2^255-1^-1] |

| Type    | Byte | Ranges        |
|---------|------|---------------|
| UInt8   | 1    | [0 ~2^8-1^]    |
| UInt16  | 2    | [0 ~ 2^16-1^]  |
| UInt32  | 4    | [0 ~ 2^32-1^]  |
| UInt64  | 8    | [0 ~ 2^64-1^]  |
| UInt128 | 16   | [0 ~ 2^128-1^] |
| UInt256 | 32   | [0 ~ 2^256-1^] |

### 浮点类型
浮点数支持 32 位和 64 位。但是浮点数有精度丢失问题，这是计算机的通病，所以一些非常重要的数据如“金额”等，不能用浮点数来存储。应该采用 Decimal。

| Type    | Alias  |
|---------|--------|
| Float32 | Float  |
| Float64 | Double |

对于浮点数，ch 支持两个特殊值 `Inf` 和 `NaN`。
```bash
> SELECT 0.5 / 0

┌─divide(0.5, 0)─┐
│            inf │
└────────────────┘

> SELECT -0.5 / 0

┌─divide(-0.5, 0)─┐
│            -inf │
└─────────────────┘
```

```bash
> SELECT 0 / 0

┌─divide(0, 0)─┐
│          nan │
└──────────────┘
```

### 定点类型

Decimal 是有符号的定点数，可以在加减乘算法过程中保持精度。支持以下写法：

- Decimal(P,S)
- Decimal32(S)
- Decimal64(S)
- Decimal128(S)
- Decimal256(S)

P 代表总位数，S 代表小数位数。

例如 `Decimal(9,5)` 表示总长度 9 字节，其中小数点 5 字节。

也就是 整数部分 4 位，可以存 [-9999 : 9999]，小数部分 5 位，可以存 [0.99999 : 0.00001]。

| P 取值      | 原生写法示例  | 等同于        |
|-------------|---------------|---------------|
| [ 1 : 9 ]   | Decimal(9,2)  | Decimal32(2)  |
| [ 10 : 18 ] | Decimal(18,2) | Decimal64(2)  |
| [ 19 : 38 ] | Decimal(38,2) | Decimal128(2) |
| [ 39 : 76 ] | Decimal(76,2) | Decimal256(2) |

!!!tip
    两个不同大小的定点类型在运算时，结果会以大的那个的精度为准。

## 布尔类型
布尔类型的关键字是 Bool，只允许 true 和 false。

```sql
CREATE TABLE test_bool
(
    `A` Int64,
    `B` Bool
)ENGINE = Memory;

INSERT INTO test_bool VALUES (1, true),(2,0);

SELECT * FROM test_bool;
┌─A─┬─B─────┐
│ 1 │ true  │
│ 2 │ false │
└───┴───────┘
```

ch 没有布尔类型，底层使用的是 Uint8 替代，并限制只能存储 true(1) 或 false(0)

```sql
select true as col, toTypeName(col);
┌─col──┬─toTypeName(true)─┐
│ true │ Bool             │
└──────┴──────────────────┘

select true == 1 as col, toTypeName(col);
┌─col─┬─toTypeName(equals(true, 1))─┐
│   1 │ UInt8                       │
└─────┴─────────────────────────────┘
```


## 字符串类型

字符串类型包括 **定长字符串 FixedString(N)** 和 **变长字符串 String**。

- String 可以存任意数量的字符。

- FixedString(N) 要求给定字符数量，在存储时如果字符数量不足，ch 会填充空字节；如果字符数量超过则会报错。

!!!tip
    ch 没有编码的概念，你给的内容什么编码她存储和输出的就什么编码。不过建议在存储长文本的时候使用 UTF-8.

    length() 函数返回的是文本的字节数，lengthUFT8() 函数返回的是文本的字数，按照 UTF-8 编码后计算。


## 时间类型
ch 的时间类型很简洁，可以存时间戳也可以存字符串

- Date
- Date32
- Datetime
- Datetime64

### Date
Date 类型，占 2 字节，支持范围 [1970-01-01 : 2149-06-06]
```sql
CREATE TABLE dt
(
    `timestamp` Date,
    `event_id` UInt8
)
ENGINE = TinyLog;

--
INSERT INTO dt VALUES (1546300800, 1), ('2019-01-01', 2);
SELECT * FROM dt;

┌──timestamp─┬─event_id─┐
│ 2019-01-01 │        1 │
│ 2019-01-01 │        2 │
└────────────┴──────────┘
```

### Date32
Date32 类型，占 4 字节，支持范围 [1900-01-01 : 2299-12-31]
```sql
CREATE TABLE new
(
    `timestamp` Date32,
    `event_id` UInt8
)
ENGINE = TinyLog;

--
INSERT INTO new VALUES (4102444800, 1), ('2100-01-01', 2);
SELECT * FROM new;

┌──timestamp─┬─event_id─┐
│ 2100-01-01 │        1 │
│ 2100-01-01 │        2 │
└────────────┴──────────┘
```

### Datetime
Datetime 类型不仅存储日期，还存储了时间信息。在底层其实都是以 UNIX 时间戳存储。

时区信息会影响 Datetime 字段的显示和解析。时区信息不是存储在行上的，而是存储在列上的 metadata 中。

在建表的时候如果没有显式的指定时区，ch 会选择服务器的时区信息。当然也可以在建表的时候指定。
```sql
CREATE TABLE new
(
    `timestamp` Datetime('UTC') -- 按照标准 UTC 时区
) ENGINE = TinyLog;

CREATE TABLE new2
(
    `timestamp` Datetime -- 按照服务器上的时区，如 Datetime('Asia/Shanghai')
) ENGINE = TinyLog;
```

[更多例子](https://clickhouse.com/docs/en/sql-reference/data-types/datetime)

### Datetime64

Datetime64 跟 Datetime 相比可以更精确到亚秒。在使用 Datetime64 的时候要指定精度。如：`Datetime64(3)`。

```sql
CREATE TABLE dt
(
    `timestamp` DateTime64(3, 'Asia/Istanbul'),
    `event_id` UInt8
)
ENGINE = TinyLog;
--
INSERT INTO dt Values (1546300800123, 1), (1546300800.123, 2), ('2019-01-01 00:00:00', 3);
--
SELECT * FROM dt;

┌───────────────timestamp─┬─event_id─┐
│ 2019-01-01 03:00:00.123 │        1 │
│ 2019-01-01 03:00:00.123 │        2 │
│ 2019-01-01 00:00:00.000 │        3 │
└─────────────────────────┴──────────┘
```

## 枚举类型

枚举类型 Enum 包括 Enum8 和 Enum16 两种类型，保存了 `'string' = integer` 的对应关系。

Enum8 用 `'string' = Int8` 描述
Enum16 用 `'string' = Int16` 描述

创建的时候有好几种方式：

=== "基本用法"

    ```sql
    CREATE TABLE t_enum
    (
        x Enum('hello' = 1, 'world' = 2)
    )ENGINE = TinyLog;
    ```

=== "使用默认"

    ```sql
    CREATE TABLE t_enum
    (
        x Enum('hello', 'world')
    )ENGINE = TinyLog;
    ```

    这种方式默认从 1 开始。

=== "指定起始值"

    ```sql
    CREATE TABLE t_enum
    (
        x Enum('hello' = 8, 'world')
    )ENGINE = TinyLog;
    ```

    指定起始值为 8，这样 hello 值为 8，world 值为 9，以此类推。

当插入枚举范围以外的值会报错。

查询的时候默认返回 Enum 的 string，要想返回 Integer 可以使用 CAST 函数。
```sql
SELECT CAST(x, 'Int8') FROM t_enum;

┌─CAST(x, 'Int8')─┐
│               1 │
│               2 │
│               1 │
└─────────────────┘
```

## 复合类型

### 数组类型

`Array(T)`

由 T 类型元素组成的数组。T 可以是任意类型，包含数组类型，但不推荐多维数组，因为 ch 对多维数组的支持有限。例如不能再 MergeTree 表中存储多维数组。

```sql
SELECT array(1, 2) AS x, toTypeName(x);
-- 结果输出
┌─x─────┬─toTypeName(array(1, 2))─┐
│ [1,2] │ Array(UInt8)            │
└───────┴─────────────────────────┘
```

```sql
SELECT [1, 2] AS x, toTypeName(x);
-- 结果输出
┌─x─────┬─toTypeName([1, 2])─┐
│ [1,2] │ Array(UInt8)       │
└───────┴────────────────────┘
```

!!! warning
    数组元素中如果存在 Null 值，元素类型将变为 Nullable。

    ```sql
    SELECT [1, 2, NULL] AS x , toTypeName(x);

    -- 结果输出
    ┌─x──────────┬─toTypeName([1, 2, NULL])─┐
    │ [1,2,NULL] │ Array(Nullable(UInt8))   │
    └────────────┴──────────────────────────┘
    ```

!!! warning
    数组中的每个元素的类型都必须相同，否则会报异常

    ```sql
    SELECT [1, 'z'] AS x, toTypeName(x);

    DB::Exception: There is no supertype for types UInt8, String because some of them are String/FixedString and some of them are not
    ```

### Tuple 类型

`Tuple(T1, T2, ...)`

元组，与数组不同，元组每个元素都有单独的类型。

不能在表中（除了内存表）存储元组，只能用于临时列分组。在查询中，IN 表达式和带特定参数的 lambda 函数可以用来对临时列进行分组。

```sql
SELECT tuple(1,'a') AS x, toTypeName(x);
--结果输出
┌─x───────┬─toTypeName(tuple(1, 'a'))─┐
│ (1,'a') │ Tuple(UInt8, String)      │
└─────────┴───────────────────────────┘
```

```sql
-- 建表
CREATE TABLE t_tuple(
    c1 Tuple(String,Int8)
) ENGINE=TinyLog;

-- INSERT数据
INSERT INTO t_tuple VALUES(('jack',20));

--查询数据
SELECT * FROM t_tuple;
┌─c1──────────┐
│ ('jack',20) │
└─────────────┘
```

```sql
-- 如果插入数据类型不匹配，会报异常
INSERT INTO t_tuple VALUES(('tom','20'));
-- Type mismatch in IN or VALUES section. Expected: Int8. Got: String
```

## 其他特殊类型

### LowCardinality

`LowCardinality(data_type)`
data_type 允许 String，FixedString，Date，DateTime，除 Decimal 以外的数字类型。

低基数类型，适用于一些重复率较高的列。假设一个列通常会有 4、5 个值，那么直接用 Enum 即可，如果通常会有一百、一千个值，并且具体的值不确定，你只知道该列的基数不会太大。这种情况就可以使用 LowCardinality。

!!! tip
    根据官方的推荐：当使用字符类型的时候，可以考虑使用 LowCardinality 代替Enum。 LowCardinality 通常更加灵活和高效。



## 参考资料

[Official Document](https://clickhouse.com/docs/en/sql-reference/data-types/)
[篇三 | ClickHouse 的数据类型](https://www.cnblogs.com/jmx-bigdata/p/14021186.html)
