# 事务

!!! quote
    参考自 小林 Coding [事务隔离级别是怎么实现的？](https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7)


在 MySQL 中，可以通过 {++BEGIN++} 或 {++START TRANSACTION++} 或 {++START TRANSACTION WITH CONSISTENT SNAPSHOT++} 开启事务，通过 {++COMMIT++} 提交事务，通过 {++ROLLBACK++} 回滚事务。

如果只是执行一条「增删改」的 SQL 语句，那么 MySQL 会自动 隐式开启事务 来执行，执行完就自动提交事务。

??? example 
    ```sql
    -- 开启事务
    START TRANSACTION;
    -- 事务操作
    INSERT INTO t1 VALUES (1, 'a');
    INSERT INTO t2 VALUES (2, 'b');
    -- 提交事务
    COMMIT;
    ```

## 事务的特性

**<font color='green'>事务(Transaction)</font>**，由一组操作构成的可靠的独立的工作单元。具备 ACID 特性，即 原子性，一致性，隔离性，持久性。

1. **<font color='blue'>原子性 Atomicity</font>**：
    事务中的所有操作 **要么全部成功，要么全部失败**。只要有一项失败，整个事务的所有操作全部回滚。
2. **<font color='blue'>一致性 Consistency</font>**：
    事务的执行不能破坏数据库的完整性和一致性，**事务在执行之前和之后，数据库都必须处于一致性状态**。
3. **<font color='blue'>隔离性 Isolation</font>**：（读未提交，读已提交，可重复读，可串行化）
    在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。即 **不同的事务并发操作相同的数据时，并发执行的各个事务之间不能相互干扰**。
4. **<font color='blue'>持久性 Durability</font>**：
    **一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的**，要求遇到机器宕机、系统崩溃等意外发生后，依然能恢复到事务成功结束时的状态。


!!! tip ""
    InnoDB 通过 **<font color='#2ecc71'>日志和锁</font>** 来保证事务的 ACID 特性，具体如下：

    2. 通过 **Redo Log** 来保障事务的 **<font color='blue'>持久性</font>**
    3. 通过 **Undo Log** 来保障事务的 **<font color='blue'>原子性</font>**
    1. 通过 **MVCC机制或锁** 来保证事务的 **<font color='blue'>隔离性</font>**
    4. 通过 **持久性+原子性+隔离性** 来保证 **<font color='blue'>一致性</font>**


## 并行事务会引发的问题

1. **<font color='#d50000'>脏读 Dirty Read</font>**：
    事务 A 读到了事务 B 还未提交的数据。

2. **<font color='#f44336'>不可重复读 Non-Repeatable Read</font>**：
    事务 A 读取某些数据后，再次读取该数据发现与上次不同，因为事务 B 对其进行了变更或删除。

3. **<font color='#ef9a9a'>幻读 Phantom Read</font>**：
    事务 A 在读某个范围，事务 B 新增或删除了满足该范围的记录，当 A 再次进行查询的时候发现多了或少了。

!!! note ""

    === "脏读"

        如果一个事务<font color='green'>「读到」</font>了另一个事务<font color='green'>「还未提交的修改后的数据」</font>，就意味着 **<font color='blue'>脏读</font>**。

        ![dirty_read](https://blogpicure.oss-cn-shenzhen.aliyuncs.com/blog/illustration-pic/MySQL/dirty_read.png)

        事务 A 还没提交意味着有可能触发回滚，那么事务 B 读到的数据并不能保证是最终的数据，这就是脏读。

    === "不可重读"

        在一个事务内<font color='green'>「多次读取同一个数据」</font>，如果每次读取的<font color='green'>「数据不一样」</font>，就说明出现了 **<font color='blue'>不可重复读</font>**。

        ![non_repeatable_read](https://blogpicure.oss-cn-shenzhen.aliyuncs.com/blog/illustration-pic/MySQL/not_repeatable_read.png)

        事务 A 在读取数据的过程中，事务 B 修改了数据，导致事务 A 两次读取的数据不一样，这就是不可重复读。

    === "幻读"

        在一个事务内<font color='green'>「多次读取同一个范围的数据」</font>，如果每次读取的<font color='green'>「数量不一样」</font>，就说明出现了 **<font color='blue'>幻读</font>**。    
        
        ![phantom_read](https://blogpicure.oss-cn-shenzhen.aliyuncs.com/blog/illustration-pic/MySQL/phantom_read.png)

        事务 A 在读取数据的过程中，事务 B 新增了数据，导致事务 A 两次读取的数据量不一样，这就是幻读。


**<font color='#d50000'>脏读</font>**、**<font color='#f44336'>不可重复读</font>** 和 **<font color='#ef9a9a'>幻读</font>** 的区别在于：

- 幻读是在同一事务中，相同条件下，两次查询出来的 **记录数** 不一样；
- 不可重复读是在同一事务中，相同条件下，两次查询出来的 **数据** 不一样；
- 脏读是读到了未提交的数据。

## 事务隔离级别

!!!note
    对于上述问题，SQL 标准提出了四种隔离级别来规避这些问题，分别是： **<font color='#004d40'>读未提交</font>**、**<font color='#00796b'>读提交</font>**、**<font color='#00897b'>可重复度</font>**、**<font color='#4db6ac'>串行化</font>**。

1. **<font color='#004d40'>读未提交 Read Uncommitted</font>**：
    指一个事务 A 还没提交时，它做的变更 **<font color='orange'>就已经能</font>** 被其他事务读到。这会导致 **<font color='#d50000'>脏读</font>**、**<font color='#f44336'>不可重复读</font>** 和 **<font color='#ef9a9a'>幻读</font>**。
2. **<font color='#00796b'>读提交 Read Committed</font>**：
    指一个事务 A 提交以后，它做的变更 **<font color='orange'>才能</font>** 被其他事务读到。这会导致 **<font color='#f44336'>不可重复读</font>** 和 **<font color='#ef9a9a'>幻读</font>**。
3. **<font color='#00897b'>可重复读 Repeatable Read</font>**：
    指一个事务 B 执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。只有自己这个事务 B 提交以后，**<font color='orange'>才能</font>** 看到最新的数据。这会导致 **<font color='#ef9a9a'>幻读</font>**。
4. **<font color='#4db6ac'>串行化 Serializable</font>**：
    对记录加上读写锁，当多个事务对这条记录进行读写操作时，如果发生读写冲突，后访问的事务必须等前一个事务执行完成才能继续。这是性能最差的隔离级别，但是可以彻底避免幻读。

!!! tip ""
    - 按隔离水平高低排序如下: **<font color='#4db6ac'>串行化</font>** > **<font color='#00897b'>可重复读</font>** > **<font color='#00796b'>读提交</font>** > **<font color='#004d40'>读未提交</font>**

    - 不同的隔离级别会导致不同的问题，如下表所示：

    | **<font color='#004d40'>读未提交</font>**                    | **<font color='#00796b'>读已提交</font>**                    | **<font color='#00897b'>可重复读</font>**              | **<font color='#4db6ac'>串行化</font>** |
    |------------------------------------------------------------|--------------------------------------------------------------|--------------------------------------------------------|-----------------------------------------|
    | :material-check: **<font color='#d50000'>脏读</font>**       |                                                              |                                                        |                                         |
    | :material-check: **<font color='#f44336'>不可重复读</font>** | :material-check: **<font color='#f44336'>不可重复读</font>** |                                                        |                                         |
    | :material-check: **<font color='#ef9a9a'>幻读</font>**       | :material-check: **<font color='#ef9a9a'>幻读</font>**       | :material-check: **<font color='#ef9a9a'>幻读</font>** |                                         |


MySQL 支持这 4 种隔离级别，可以通过 `SET TRANSACTION ISOLATION LEVEL` 来设置。但和 SQL 标准不同的是，MySQL 的默认隔离级别是 **<font color='#00897b'>可重复读</font>**，而不是 **<font color='#00796b'>读提交</font>**。
并且在 MySQL 中，**<font color='#00897b'>可重复读</font>** 是通过 **MVCC** 机制来实现的。可以很大程度上（不是彻底）避免 **<font color='#ef9a9a'>幻读</font>** 问题。

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### MySQL 可重复读解决方案

具体的方案有两种：

1. 针对 **快照读** ，是通过 **MVCC** 解决幻读问题；因为 **<font color='#00897b'>可重复读</font>** 隔离级别下，事务执行时会创建一个 ReadView，用于保存事务启动时的快照。
这样在事务执行过程中，其他事务对数据的修改不会影响到当前事务的读取。就算事务执行期间数据被修改也不影响。

2. 针对 **当前读** ，是通过 **Next-Key Lock** 解决幻读问题；因为在执行 `SELECT ... FOR UPDATE` 语句时，会对查询的数据加上 Next-Key Lock，
其他事务如果在 Next-Key Lock 锁住的范围内插入删除数据，就会被阻塞，直到当前事务执行完成，这样就避免了幻读问题。

!!! example ""
    <div class="grid" markdown>

    !!! Info "示例"
        | 事务 A                                                                   | 事务 B                                                                   |
        |--------------------------------------------------------------------------|--------------------------------------------------------------------------|
        | 启动事务 A                                                               | 启动事务 B                                                               |
        | ==查询得到余额 v0 100w==                                                 |                                                                          |
        |                                                                          | 查询得到余额 100w                                                        |
        |                                                                          | 修改余额为 200w                                                          |
        | ==查询余额 v1==                                                          |                                                                          |
        |                                                                          | <font color='white' style="background-color: green;"> 提交事务 B </font> |
        | ==查询余额 v2==                                                          |                                                                          |
        | <font color='white' style="background-color: green;"> 提交事务 A </font> |                                                                          |
        | ==查询余额 v3==                                                          |                                                                          |


    === "**<font color='#004d40'>读未提交</font>**"
        | 事务 A                                                                   | 事务 B                                                                   |
        |--------------------------------------------------------------------------|--------------------------------------------------------------------------|
        | 启动事务 A                                                               | 启动事务 B                                                               |
        | ==查询得到余额 v0 100w==                                                 |                                                                          |
        |                                                                          | 查询得到余额 100w                                                        |
        |                                                                          | 修改余额为 200w                                                          |
        | ==查询余额 v1 200w==                                                     |                                                                          |
        |                                                                          | <font color='white' style="background-color: green;"> 提交事务 B </font> |
        | ==查询余额 v2 200w==                                                     |                                                                          |
        | <font color='white' style="background-color: green;"> 提交事务 A </font> |                                                                          |
        | ==查询余额 v3 200w==                                                     |                                                                          |

        在「**<font color='#004d40'>读未提交</font>**」隔离级别下，事务 B 修改了余额，事务 A 在查询余额 v1 时就会直接读到 200w，这就是脏读。
        v2、v3 自然也是读到 200w。

    === "**<font color='#00796b'>读已提交</font>**"
        | 事务 A                                                                   | 事务 B                                                                   |
        |--------------------------------------------------------------------------|--------------------------------------------------------------------------|
        | 启动事务 A                                                               | 启动事务 B                                                               |
        | ==查询得到余额 v0 100w==                                                 |                                                                          |
        |                                                                          | 查询得到余额 100w                                                        |
        |                                                                          | 修改余额为 200w                                                          |
        | ==查询余额 v1 100w==                                                     |                                                                          |
        |                                                                          | <font color='white' style="background-color: green;"> 提交事务 B </font> |
        | ==查询余额 v2 200w==                                                     |                                                                          |
        | <font color='white' style="background-color: green;"> 提交事务 A </font> |                                                                          |
        | ==查询余额 v3 200w==                                                     |                                                                          |

        在「**<font color='#00796b'>读已提交</font>**」隔离级别下，事务 B 修改了余额，事务 A 在查询余额 v1 时还是读到 100w，因为事务 B 还未提交。
        当事务 B 提交以后，事务 A 在查询余额 v2 时读到 200w，v3 也是 200w。

    === "**<font color='#00897b'>可重复读</font>**"
        | 事务 A                                                                   | 事务 B                                                                   |
        |--------------------------------------------------------------------------|--------------------------------------------------------------------------|
        | 启动事务 A                                                               | 启动事务 B                                                               |
        | ==查询得到余额 v0 100w==                                                 |                                                                          |
        |                                                                          | 查询得到余额 100w                                                        |
        |                                                                          | 修改余额为 200w                                                          |
        | ==查询余额 v1 100w==                                                     |                                                                          |
        |                                                                          | <font color='white' style="background-color: green;"> 提交事务 B </font> |
        | ==查询余额 v2 100w==                                                     |                                                                          |
        | <font color='white' style="background-color: green;"> 提交事务 A </font> |                                                                          |
        | ==查询余额 v3 200w==                                                     |                                                                          |

        在「**<font color='#00897b'>可重复读</font>**」隔离级别下，事务 B 修改了余额，事务 A 在查询余额 v1 时读到 100w，v2 也是 100w，因为此时事务 A 还没有提交，它的快照是 100w。
        当事务 A 提交以后，事务 A 在查询余额 v3 时读到就是 200w。

    === "**<font color='#4db6ac'>串行化</font>**"
        | 事务 A                                                                   | 事务 B                                                                   |
        |--------------------------------------------------------------------------|--------------------------------------------------------------------------|
        | 启动事务 A                                                               | 启动事务 B                                                               |
        | ==查询得到余额 v0 100w==                                                 |                                                                          |
        |                                                                          | 查询得到余额 100w                                                        |
        |                                                                          | 修改余额为 200w                                                          |
        | ==查询余额 v1 100w==                                                     |                                                                          |
        |                                                                          | <font color='white' style="background-color: green;"> 提交事务 B </font> |
        | ==查询余额 v2 100w==                                                     |                                                                          |
        | <font color='white' style="background-color: green;"> 提交事务 A </font> |                                                                          |
        | ==查询余额 v3 100w==                                                     |                                                                          |

        在「**<font color='#4db6ac'>串行化</font>**」隔离级别下，事务 B 修改余额时会被阻塞，因为事务 A 在一开始查询v0时就对余额加了锁，直到事务 A 提交后，事务 B 才能继续执行。
        所以事务 A 在查询余额 v1、v2、v3 时都是 100w。

    </div>

### 四种隔离级别的实现

- 对于「**<font color='#004d40'>读未提交</font>**」级别来说，因为可以读到未提交的数据，所以直接读最新数据就行。
- 对于「**<font color='#4db6ac'>串行化</font>**」级别来说，通过加读写锁的方式直接避免并行访问。
- 对于「**<font color='#00796b'>读已提交</font>**」和「**<font color='#00897b'>可重复读</font>**」级别来说，需要通过 ReadView 来实现。ReadView 就是对数据打了一个快照。
「**<font color='#00796b'>读已提交</font>**」级别是在「每个语句执行前」都重新生成一个 ReadView, 而「**<font color='#00897b'>可重复读</font>**」级别是在「事务启动时」生成一个 ReadView，然后整个事务期间都用这个 ReadView 读取到的数据。


!!! warning ""
    注意，开始执行事务，并不意味着启动了事务。MySQL 有两种开启事务的方式：
    
    1. `begin` 或 `start transaction` 命令，这种方式只有在执行到第一条查询语句时才会启动事务，这时候才会生成 ReadView。
    2. `start transaction with consistent snapshot` 命令，这种方式在执行到这条命令时就会启动事务，生成 ReadView。


## ReadView 和 MVCC



*[快照读]：普通的 SELECT 语句
*[当前读]：`UPDATE`、`DELETE`、`INSERT` 语句和 `SELECT ... FOR UPDATE` 语句
*[MVCC]: Multi-Version Concurrency Control 多版本并发控制
*[Redo Log]: 重做日志
*[Undo Log]: 回滚日志
*[ACID]: Atomicity, Consistency, Isolation, Durability
*[脏读]: Dirty Read
*[幻读]: Phantom Read
*[不可重复读]: Non-Repeatable Read
*[持久性]: Durability
*[一致性]: Consistency
*[隔离性]: Isolation
*[原子性]: Atomicity
