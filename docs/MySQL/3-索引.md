# 索引

在数据库的使用过程中，查询是占据了绝大部分，即使是更新删除，也得先查到对应的数据，所以如何加快查找速度是数据库要解决的一个重大问题。

想要加快查询的速度，可以往前一步思考：**如何存储数据，才能在查询的时候更快？**

所以 **如何加快查询速度** 问题就变成一个 **如何组织数据的结构** 问题。

而 {++索引++} 就是一种解决方法。换言之：索引，是一种数据结构。

- 索引的优点：
    - 加快查询速度
- 索引的缺点：
    - 维护索引需要消耗数据库资源
    - 索引需要占用磁盘空间
    - 当对标的数据进行增删改的时候，因为需要维护索引，速度会受影响

## 索引分类

MySQL 中的索引分为：

- InnoDB (主键索引、唯一索引、单值索引、复合索引):
    - 主键索引：一个列被设定为主键后会自动建立主键索引，不允许 NULL；InnoDB为聚簇索引
    - 唯一索引：列的值必须唯一，但允许 NULL
    - 单值索引(普通索引)：即一个索引只包含一个列，一个表可以有多个单值索引
    - 复合索引：即一个索引包含多个列
- MyISAM (主键索引、唯一索引、单值索引、复合索引、全文索引)
    - 全文索引 Full Text：

!!! tip
    单值索引 与 复合索引：
    
    给 name 和 age 分别建立了单值索引，在 `WHERE name` 或者 `WHERE age` 的时候会使用上索引。
    但是 `WHERE name AND age` 的时候就用不上索引。

    如果给 name 和 age 一起建立了复合索引，就能用上索引。

## 索引基本操作

### 主键索引

主键索引在建表时创建主键时自动创建。

如果建表的时候不指定主键，MySQL 会默认创建一个 row_id 作为主键并创建索引。

```shell
mysql> CREATE TABLE t_user(
    ->    id varchar(20) primary key, 
    ->    name varchar(20)
    -> );
Query OK, 0 rows affected (0.04 sec)

mysql> show index from t_user;
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| t_user |          0 | PRIMARY  |            1 | id          | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.01 sec)
```

### 唯一索引

- 建表时创建索引：
    ```shell
    mysql> CREATE TABLE t_person(
        ->     id varchar(20),
        ->     name varchar(20),
        -> 
        ->     UNIQUE(name)
        -> );
    Query OK, 0 rows affected (0.05 sec)

    mysql> show index from t_person;
    +----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | t_person |          0 | name     |            1 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    1 row in set (0.01 sec)
    ```

    即使没有指定索引，MySQL 也会默认为指定了 UNIQUE 约束的列创建唯一索引。

    ```shell
    mysql> CREATE TABLE t_user(
        ->     id varchar(20) UNIQUE,
        ->     name varchar(20)
        -> );
    Query OK, 0 rows affected (0.05 sec)

    mysql> show index from t_user;
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | t_user |          0 | id       |            1 | id          | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    1 row in set (0.01 sec)
    ```

- 建表后创建索引：
    ```shell
    mysql> CREATE UNIQUE INDEX 索引名 ON 表名(列名);
    ```


### 单值索引

- 建表时创建索引：
    ```shell
    mysql> CREATE TABLE t_user(
        ->     id varchar(20),
        ->     name varchar(20),
        -> 
        ->     KEY(name)
        -> );
    Query OK, 0 rows affected (0.06 sec)

    mysql> show index from t_user;
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | t_user |          1 | name     |            1 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    1 row in set (0.01 sec)
    ```
    建表时创建的索引无法命名，其索引名与列名一致。


- 建表后创建索引：
    ```shell
    mysql> CREATE INDEX 索引名 ON 表名(列名);
    ```
    ```shell
    mysql> CREATE INDEX idx_id ON t_user(id);
    Query OK, 0 rows affected (0.03 sec)
    Records: 0  Duplicates: 0  Warnings: 0

    mysql> show index from t_user;
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | t_user |          1 | name     |            1 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    | t_user |          1 | idx_id   |            1 | id          | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    2 rows in set (0.01 sec)
    ```

- 删除索引：
    ```shell
    mysql> DROP INDEX 索引名 ON 表名;
    ```
    ```shell
    mysql> DROP INDEX idx_id ON t_user;
    Query OK, 0 rows affected (0.03 sec)
    Records: 0  Duplicates: 0  Warnings: 0

    mysql> show index from t_user;
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | t_user |          1 | name     |            1 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    1 row in set (0.00 sec)
    ```


### 复合索引

- 建表时创建索引：
    ```shell
    mysql> CREATE TABLE t_user(
        ->     id varchar(20),
        ->     name varchar(20),
        ->     age int,
        -> 
        ->    KEY(name, age)
        -> );
    Query OK, 0 rows affected (0.05 sec)

    mysql> show index from t_user;
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | t_user |          1 | name     |            1 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    | t_user |          1 | name     |            2 | age         | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    2 rows in set (0.01 sec)
    ```

- 建表后创建索引：
    ```shell
    CREATE INDEX 索引名称 ON 表名(列名1, 列名2, ...);
    ```

!!! tip
    命中索引的原则：

    给 name 和 age 建立复合索引，在查询时，遵循：

    1. 最左匹配原则：
        - WHERE name, age, bir -> ==可以== 使用索引
        - WHERE name, bir, age -> 无法 使用索引
        - WHERE bir, age, name -> 无法 使用索引
        - WHERE age, bir       -> 无法 使用索引
        - WHERE name, bir      -> 无法 使用索引
    2. MySQL 优化器会动态调整字段顺序以顺利使用索引，所以最终是以下情况(只要包含复合索引的字段就能命中)：
        - WHERE name, age, bir -> ==可以== 使用索引
        - WHERE name, bir, age -> ==可以== 使用索引，会被调整为 name, age, bir
        - WHERE bir, age, name -> ==可以== 使用索引，会被调整为 name, age, bir
        - WHERE age, bir       -> 无法使用索引
        - WHERE name, bir      -> ==可以== 使用索引，会先查询 name


## 索引结构
MySQL 的索引使用的是 B+树。这是一种 N 叉树。
![](../../../BLOG-IMG/blog/illustration-pic/MySQL/b+tree2.png)