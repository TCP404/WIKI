# 锁
!!! quote
    参考自 小林 Coding [MySQL 有哪些锁？](https://xiaolincoding.com/mysql/lock/mysql_lock.html)
## 全局锁

```sql title="上锁"
-- 手动加全局锁
FLUSH TABLES WITH READ LOCK;
```
执行以后整个数据库就处于只读状态了，其他线程执行的 insert, update, delete, alter table, drop table 等语句都会被阻塞，直到执行 UNLOCK TABLES 释放锁。


```sql title="释放锁"
-- 释放全局锁
UNLOCK TABLES;
```

如果会话断开了，全局锁也会自动被释放。

全局锁主要用于 **<font color='blue'>全库逻辑备份</font>**，加全局锁不至于因为在备份期间数据或表结构更新导致备份不一致。
但是全局锁会导致整个库的读写都被阻塞，生产业务等于停滞。

通常更合适的做法是开启事务，在「可重复读」的隔离级别下，开启事务会在备份期间生成一个 ReadView，加上 MVCC 机制，可以保证备份的数据是一致的，同时生产业务可以生产增删改。

MySQL 默认引擎 InnoDB 支持事务，默认隔离级别为「可重复读」，而 MyISAM 不支持事务，所以在备份 MyISAM 表时，需要加全局锁。


## 表级锁

### 表锁

```sql title="上锁"
-- 手动加表锁
LOCK TABLES table_name [READ | WRITE];
```

```sql title="释放锁"
-- 释放表锁
UNLOCK TABLES;
```


### 元数据锁


### 意向锁

```sql title="上锁"
-- 手动加意向共享锁（读锁）
SELECT ... LOCK IN SHARE MODE;

-- 手动加意向排他锁（写锁）
SELECT ... FOR UPDATE;
```


### AUTO-INC 锁


## 行级锁


