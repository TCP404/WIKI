# 文件操作

file 类是在 os 包中的，封装了底层的文件描述符和相关信息，同时封装了 Read 和 Write 的实现

## 导包
```go
import "os"
```

## 文件信息 FileInfo
```go
// A FileInfo describes a file and is returned by Stat and Lstat.
type FileInfo interface {
	Name() string       // 文件名
	Size() int64        // 文件大小，单位：byte
	Mode() FileMode     // 文件权限
	ModTime() time.Time // 文件修改时间
	IsDir() bool        // 是否目录
	Sys() interface{}   // 基础数据源 (可以返回 nil)
}
```
`FileInfo` 类型装载了各种描述文件信息的方法。通过 `Stat()` 或 `Lstat()` 可以获得

```go
func Stat(name string) (FileInfo, error) {}
func Lstat(name string) (FileInfo, error) {}
```

eg：
```go
func main() {

	fileInfo, err := os.Stat("E:\\---CODE\\GO\\root\\src\\boii.xyz\\study\\Helloworld\\abc.txt")
	if err != nil {
		fmt.Println("Err:", err)
		return
	}
	fmt.Println(fileInfo.Name())	// abc.txt
	fmt.Println(fileInfo.Size())	// 0
	fmt.Println(fileInfo.Mode())	// -rw-rw-rw-
	fmt.Println(fileInfo.ModTime()) // 2021-02-08 21:29:31.4224976 +0800 CST
	fmt.Println(fileInfo.IsDir())	// false
	fmt.Println(fileInfo.Sys())		// &{32 {1857742672 30866974} {1857742672 30866974} {1857742672 30866974} 0 0}

}
```
## 权限 FileMode

```go
const (
	// The single letters are the abbreviations
	// used by the String method's formatting.
	ModeDir        FileMode = 1 << (32 - 1 - iota) // d: is a directory
	ModeAppend                                     // a: append-only
	ModeExclusive                                  // l: exclusive use
	ModeTemporary                                  // T: temporary file; Plan 9 only
	ModeSymlink                                    // L: symbolic link
	ModeDevice                                     // D: device file
	ModeNamedPipe                                  // p: named pipe (FIFO)
	ModeSocket                                     // S: Unix domain socket
	ModeSetuid                                     // u: setuid
	ModeSetgid                                     // g: setgid
	ModeCharDevice                                 // c: Unix character device, when ModeDevice is set
	ModeSticky                                     // t: sticky
	ModeIrregular                                  // ?: non-regular file; nothing else is known about this file

	// Mask for the type bits. For regular files, none will be set.
	ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular

	ModePerm FileMode = 0777 // Unix permission bits
)
```

## 打开模式 Flag
```go
// OpenFile的标志包装基础系统的标志。并非所有标志都可以在给定的系统上实现。
const (
	//必须指定 O_RDONLY, O_WRONLY, or O_RDWR 其中一个
	O_RDONLY int = syscall.O_RDONLY // 只读
	O_WRONLY int = syscall.O_WRONLY // 只写
	O_RDWR   int = syscall.O_RDWR   // 读写
	// 以下值用来控制行为
	O_APPEND int = syscall.O_APPEND // 追加写
	O_CREATE int = syscall.O_CREAT  // 若文件不存在则创建
	O_EXCL   int = syscall.O_EXCL   // 和 O_CREATE 配合使用, 文件必须不存在.
	O_SYNC   int = syscall.O_SYNC   // 打开文件用于 同步 I/O
	O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
)
```

## 创建目录
函数签名：
```go
func Mkdir(name string, perm FileMode) error {}
func MkdirAll(path string, perm FileMode) error {}
```
`Mkdir` 用于创建一个目录，目录存在时则创建失败
`MkdirAll` 用于递归创建目录，目录存在时，则创建失败

## 创建文件
```go
func Create(name string) (*File, error) {}
func NewFile(fd uintptr, name string) *File {}
```
- **`Create(name string) (*File, error)`**
    - 创建一个名为 `name` 的文件，默认权限 `0666`，文件描述符为 `O_RDWR` 读写，如果文件已存在则内容会被清空。
    - 如果创建成功，访问的文件对象可用于 I/O。
    - 如果出错，错误类型为 `*PathError`。
- **`NewFile(fd uintptr, name string) *File`**
    - 使用给出的 `fd` Unix文件描述符和名称创建一个名为 `name` 的文件。

```go
func main() {
    f, err := os.Create("abc.txt")
    if err != nil {
        fmt.Println("Err:", err)
        return
    }
    fmt.Println("文件创建成功")
}
```

## 删除文件、目录
```go
func Remove(name string) error {}
func RemoveAll(path string) error {}
```
`Remove()`：删除名为 `name` 的文件或目录，目录非空时删除目录会失败。如果删除失败，则返回 `*PathError`。
`RemoveAll()`：递归删除 `path` 的所有文件或目录，不管目录是否为空。


```go
func main() {

    err1 := os.Remove("abc.txt")
    if err1 != nil {
        fmt.Println("Err:", err1)
        return
    }
    fmt.Println("删除文件成功")


    err2 := os.Remove("acc/abc")
    if err2 != nil {
        fmt.Println("Err:", err2)
        return
    }
    fmt.Println("删除目录成功")
}
```

## 打开文件
```go
func Open(name string) (*File, error) {}
func OpenFile(name string, flag int, perm FileMode) (*File, error) {}
```

- **`Open(name string) (*File, error)`**
    - 打开一个名为 `name` 的文件用于读取，文件描述符为 `O_RDONLY` 只读。
    - 如果打开成功，返回的文件对象的方法可用于读取数据。
    - 如果出错，错误类型为 `*PathError`。
- **`OpenFile(name string, flag int, perm FileMode) (*File, error)`**
    - 打开一个名为 `name` 的文件，以 `flag` 的模式打开；若文件不存在则创建文件，文件权限为 `perm`。
    - 如果打开成功，返回的文件对象的方法可用于读取数据。
    - 如果出错，错误类型为 `*PathError`。

eg：

```go
func main() {
	f, err := os.Open("a.txt")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(f)
}
```

```go
func main() {
	f, err := os.OpenFile("a.txt", os.O_RDONLY | os.O_WRONLY, os.ModePerm)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(f)
}
```


## 关闭文件
```go
func (f *File) Close() error {}
```
关闭已打开的文件。

eg：
```go
func main() {
	f, err := os.OpenFile("a.txt", os.O_RDONLY | os.O_WRONLY, os.ModePerm)
	if err != nil {
		fmt.Println(err)
	}

	f.Close()
}
```

更稳妥的做法是：
```go
func main() {
	f, err := os.OpenFile("a.txt", os.O_RDONLY | os.O_WRONLY, os.ModePerm)
	defer f.Close()

	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(f)
}
```
文件打开后紧接着跟着 `defer` 修饰关闭函数。防止中途发生 `panic` 来不及关闭文件。